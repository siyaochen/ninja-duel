/**
 * GameFrame
 * This class creates and updates the game frame 
 * @author Siyao Chen, Vicki Xu
 * @version 1.0
 * May 23, 2017
 */


import java.awt.image.BufferedImage;

import java.io.FilenameFilter;
import java.util.List;
import java.util.ArrayList;

//Graphics & GUI imports
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

import javax.swing.JFrame;
import javax.swing.JPanel;
import java.awt.Toolkit;
import java.awt.Graphics;
import java.awt.Color;
import java.awt.Font;

//File imports
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;

//Keyboard imports
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

//actions imports
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

/*
 //Mouse imports
 import java.awt.event.MouseListener;
 import java.awt.event.MouseEvent;
 */


class GameFrame extends JFrame {

    //static
    final File dir = new File("c:\\temp\\java\\p1");
    // static
    final File dir2 = new File("c:\\temp\\java\\p2");
    //static final File dir2 = new File("/Users/vicki/Documents/ComSci-Sum/p2");
    public int spriteNum;
    public String spriteUsed1;
    public String spriteUsed2;

    public List<Integer> explodeCoordinates;

    public long bombLasting;

    //class variable (non-static)
    static GameAreaPanel gamePanel;

    Field gameField;
    Player player1;
    Player player2;

    //Constructor - this runs first
    GameFrame() {

        super("Ninja Duel");
        this.setSize(480, 380);
        this.setUndecorated(true); //remove title bar
        this.setResizable(false);
        setLocationRelativeTo(null);

        player1 = new Player(1);
        //player1.getNumLives();
        player2 = new Player(2);
        //player2.getNumLives();

        spriteUsed1 = ("p1_down1.png");
        spriteUsed2 = ("p2_down1.png");
        spriteNum = 0;

        gameField = new Field(player1, player2);

        bombLasting = 0;
        explodeCoordinates = new ArrayList<Integer>();

        //Set up the game panel (where we put our graphics)
        gamePanel = new GameAreaPanel();
        this.add(new GameAreaPanel());

        MyKeyListener keyListener = new MyKeyListener();
        this.addKeyListener(keyListener);

        this.requestFocusInWindow(); //make sure the frame has focus
        this.setVisible(true);

        //Start the game loop in a separate thread
        Thread t = new Thread(new Runnable() {
            public void run() {
                animate();
            }
        }); //start the gameLoop
        t.start();
    }

    //the main gameloop - this is where the game state is updated
    public void animate() {

        while (true) {
            //Tile[][] tileArray = gameField.getField();
            //play1Lives = player1.getnumLives();
            //play2Lives = player2.getnumLives();
            player1.move(gameField);
            player2.move(gameField);
            //player2.move(gameField);
            try {
                Thread.sleep(50);
            } catch (Exception exc) {} //delay
            this.repaint();

        }

    }

    /** --------- INNER CLASSES ------------- **/

    // Inner class for the the game area - This is where all the drawing of the screen occurs
    private class GameAreaPanel extends JPanel {

        public void paintComponent(Graphics g) {

            // Call to super method for all other necessary functions
            super.paintComponents(g);
            setDoubleBuffered(true);

            try {
                g.drawImage(ImageIO.read(new File("gameBackground.png")), 0, 0, null);
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            int x = gameField.X_DISPLACEMENT;
            int y = gameField.Y_DISPLACEMENT;

            for (int i = 0; i < gameField.tileArray.length; i++) {
                for (int j = 0; j < gameField.tileArray[i].length; j++) {
                    if (j == 0 && i != 0) {
                        x = gameField.X_DISPLACEMENT;
                        y += gameField.TILE_SIZE;
                    }
                    g.drawImage((gameField.tileArray[i][j].getSprite()), x, y, null);
                    x += gameField.TILE_SIZE;
                }
            }

            int fontSize = 18;

            g.setFont(new Font("Serif", Font.BOLD, fontSize));
            g.setColor(Color.white);

            g.drawString((player1.numLives) + "", 208, 25);
            g.drawString((player2.numLives) + "", 280, 25);

            try {
                g.drawImage(ImageIO.read(new File("p1/" + spriteUsed1)), player1.xCoordinate, player1.yCoordinate, null);
                g.drawImage(ImageIO.read(new File("p2/" + spriteUsed2)), player2.xCoordinate, player2.yCoordinate, null);
            } catch (IOException e) {
                e.printStackTrace();
            }

            // Declare a bomb variable
            Bomb bomb;

            // Check for bomb explosion
            for (int i = 0; i < gameField.bombs.size(); i++) {
                bomb = gameField.bombs.get(i);

                if (bomb.checkExplode()) {
                    // Explode and get list of coordinates to animate
                    explodeCoordinates = bomb.explode(gameField);

                    bombLasting = System.currentTimeMillis();
                }
            }

            player1.immune = false;
            player2.immune = false;

            if (System.currentTimeMillis() <= bombLasting + 1000) {
                for (int j = 0; j < explodeCoordinates.size(); j++) {
                    // Calculate coordinates to draw on screen
                    int xCoordinate = Field.xPosToCoordinate(explodeCoordinates.get(j) % Field.FIELD_SIZE);
                    int yCoordinate = Field.yPosToCoordinate(explodeCoordinates.get(j) / Field.FIELD_SIZE);

                    // Calculate which image to use
                    int imgIndex = Bomb.getExplosionSpriteIndex(explodeCoordinates, j);

                    // Draw the image
                    g.drawImage(Bomb.explosionSprites[imgIndex], xCoordinate, yCoordinate, null);
                    System.out.println("Explosion drawn at: (" + Field.xCoordinateToPos(xCoordinate) + "," + Field.yCoordinateToPos(yCoordinate) + ")");
                }
            }

            // Draw current bombs
            for (Bomb b : gameField.bombs) {
                g.drawImage(b.bombSprite, b.xPos * Field.TILE_SIZE + Field.X_DISPLACEMENT, b.yPos * Field.TILE_SIZE + Field.Y_DISPLACEMENT, null);
            }
        }
    }

    private class MyKeyListener implements KeyListener {

        public void keyTyped(KeyEvent e) {

        }

        public void keyPressed(KeyEvent e) {

            if (e.getKeyCode() == e.VK_ESCAPE) {
                System.out.println("ESCAPE");
                System.exit(0);
            }

            spriteNum++;
            if (spriteNum == 3) {
                spriteNum = 1;
            }

            //TESTING PLAYER1
            if (e.getKeyChar() == 'a') { //Good time to use a Switch statement
                spriteUsed1 = ("p1_left" + spriteNum + ".png");
                player1.xSpeed = -3;
            } else if (e.getKeyChar() == 'x') {
                spriteUsed1 = ("p1_down" + spriteNum + ".png");
                player1.ySpeed = 3;
            } else if (e.getKeyChar() == 'd') {
                //System.out.println("p1: right");
                spriteUsed1 = ("p1_right" + spriteNum + ".png");
                player1.xSpeed = 3;
            } else if (e.getKeyChar() == 'w') {
                // System.out.println("p1: up");
                spriteUsed1 = ("p1_up" + spriteNum + ".png");
                player1.ySpeed = -3;
            } else if (e.getKeyCode() == KeyEvent.VK_SPACE) {
                player1.placeBomb(gameField);
            } //note - would be better to make player class and pass in map, test movement in there

            //TESTING PLAYER 2
            if (e.getKeyCode() == KeyEvent.VK_LEFT) { //Good time to use a Switch statement
                spriteUsed2 = ("p2_left" + spriteNum + ".png");
                player2.xSpeed = -3;
            } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {
                spriteUsed2 = ("p2_down" + spriteNum + ".png");
                player2.ySpeed = 3;
            } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
                spriteUsed2 = ("p2_right" + spriteNum + ".png");
                player2.xSpeed = 3;
            } else if (e.getKeyCode() == KeyEvent.VK_UP) {
                spriteUsed2 = ("p2_up" + spriteNum + ".png");
                player2.ySpeed = -3;
            } else if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                player2.placeBomb(gameField);
            } //note - would be better to make player class and pass in map, test movement in there

        }

        public void keyReleased(KeyEvent e) {

            //TESTING PLAYER 1
            if (e.getKeyChar() == 'a') { //Good time to use a Switch statement
                System.out.println("p1: left");
                player1.xSpeed = 0;
            } else if (e.getKeyChar() == 's') {
                System.out.println("p1: down");
                player1.ySpeed = 0;
            } else if (e.getKeyChar() == 'd') {
                System.out.println("p1: right");
                player1.xSpeed = 0;
            } else if (e.getKeyChar() == 'w') {
                System.out.println("p1: up");
                player1.ySpeed = 0;
            }

            //TESTING PLAYER 2
            if (e.getKeyCode() == KeyEvent.VK_LEFT) { //Good time to use a Switch statement
                System.out.println("p2: left");
                player2.xSpeed = 0;
            } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {
                System.out.println("p2: down");
                player2.ySpeed = 0;
            } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
                System.out.println("p2: right");
                player2.xSpeed = 0;
            } else if (e.getKeyCode() == KeyEvent.VK_UP) {
                System.out.println("p2: up");
                player2.ySpeed = 0;
            }

        }

    }

}